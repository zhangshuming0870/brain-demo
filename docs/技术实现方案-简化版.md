# 技术实现方案（简化实用版）

## 一、技术选型（简洁实用）

### 核心原则
- **简单实用**：选择成熟稳定的技术
- **快速开发**：使用简单易用的工具
- **易于维护**：代码清晰，便于理解

### 技术栈
```bash
# 创建项目（不使用 TypeScript）
npm create vue@latest renti-3d
# 选择：❌ TypeScript, ✅ Router, ✅ Pinia

# 安装核心依赖
npm install three
npm install element-plus
npm install echarts
npm install pinia
```

**为什么这样选？**
- **Three.js**：3D 渲染的标准选择，直接使用，无需复杂封装
- **Vue 3**：简单易用，开发效率高
- **JavaScript**：降低技术门槛，专注业务实现
- **Element Plus**：UI 组件丰富，快速搭建界面
- **ECharts**：图表功能完善，配置简单
- **Pinia**：状态管理简单，Vue 官方推荐

## 二、项目结构（清晰简单）

```
src/
├── App.vue
├── main.js
├── components/
│   ├── Scene/
│   │   ├── HumanModel.vue          # 人体模型
│   │   └── CrossSectionView.vue   # 横截面视图
│   ├── UI/
│   │   ├── Sidebar.vue             # 侧边栏
│   │   ├── LayerPanel.vue          # 图层面板
│   │   ├── InfoPanel.vue           # 信息面板
│   │   └── CrossSectionPanel.vue   # 横截面控制
│   └── DataViz/
│       └── ChartPanel.vue          # 图表面板
├── stores/
│   └── sceneStore.js               # 状态管理
├── utils/
│   ├── modelLoader.js              # 模型加载
│   └── anatomyData.js              # 生物知识数据
└── data/
    └── anatomy.json                # 器官数据
```

## 三、核心功能实现（简单直接）

### 1. 3D 场景搭建

**App.vue**
```vue
<template>
  <div class="app-container">
    <div ref="containerRef" class="canvas-container"></div>
    <Sidebar />
    <LayerPanel />
    <CrossSectionPanel />
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'
import Sidebar from './components/UI/Sidebar.vue'
import LayerPanel from './components/UI/LayerPanel.vue'
import CrossSectionPanel from './components/UI/CrossSectionPanel.vue'

const containerRef = ref(null)
let scene, camera, renderer, controls

onMounted(() => {
  // 初始化场景
  scene = new THREE.Scene()
  scene.background = new THREE.Color(0x1a1a1a)
  
  // 初始化相机
  camera = new THREE.PerspectiveCamera(
    50,
    containerRef.value.clientWidth / containerRef.value.clientHeight,
    0.1,
    1000
  )
  camera.position.set(0, 1.6, 5)
  
  // 初始化渲染器
  renderer = new THREE.WebGLRenderer({ antialias: true })
  renderer.setSize(containerRef.value.clientWidth, containerRef.value.clientHeight)
  renderer.shadowMap.enabled = true
  containerRef.value.appendChild(renderer.domElement)
  
  // 添加灯光
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
  scene.add(ambientLight)
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1)
  directionalLight.position.set(10, 10, 5)
  directionalLight.castShadow = true
  scene.add(directionalLight)
  
  // 添加控制器
  controls = new OrbitControls(camera, renderer.domElement)
  controls.enablePan = true
  controls.enableZoom = true
  controls.enableRotate = true
  controls.minDistance = 2
  controls.maxDistance = 20
  
  // 加载模型
  loadModel()
  
  // 动画循环
  animate()
})

function loadModel() {
  const loader = new GLTFLoader()
  loader.load('/models/human-body.glb', (gltf) => {
    const model = gltf.scene
    scene.add(model)
    
    // 设置模型位置和缩放
    model.position.set(0, 0, 0)
    model.scale.set(1, 1, 1)
    
    // 存储模型引用，用于后续操作
    window.modelRef = model
  })
}

function animate() {
  requestAnimationFrame(animate)
  controls.update()
  renderer.render(scene, camera)
}
</script>

<style scoped>
.app-container {
  width: 100vw;
  height: 100vh;
  position: relative;
}

.canvas-container {
  width: 100%;
  height: 100%;
}
</style>
```

### 2. 分层显示功能

**LayerPanel.vue**
```vue
<template>
  <div class="layer-panel">
    <h3>图层控制</h3>
    <div v-for="layer in layers" :key="layer.key" class="layer-item">
      <el-switch v-model="layer.visible" @change="toggleLayer(layer)" />
      <span>{{ layer.label }}</span>
      <el-slider
        v-model="layer.opacity"
        :min="0"
        :max="1"
        :step="0.1"
        :disabled="!layer.visible"
        @change="setOpacity(layer)"
      />
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const layers = ref([
  { key: 'skin', label: '皮肤层', visible: true, opacity: 1 },
  { key: 'muscle', label: '肌肉层', visible: false, opacity: 1 },
  { key: 'skeleton', label: '骨骼层', visible: false, opacity: 1 },
  { key: 'organs', label: '器官层', visible: true, opacity: 1 },
  { key: 'vessels', label: '血管层', visible: false, opacity: 1 }
])

function toggleLayer(layer) {
  if (!window.modelRef) return
  
  window.modelRef.traverse((child) => {
    if (child.isMesh && child.userData.layer === layer.key) {
      child.visible = layer.visible
    }
  })
}

function setOpacity(layer) {
  if (!window.modelRef) return
  
  window.modelRef.traverse((child) => {
    if (child.isMesh && child.userData.layer === layer.key) {
      child.material.transparent = layer.opacity < 1
      child.material.opacity = layer.opacity
    }
  })
}
</script>
```

### 3. 横截面功能

**CrossSectionPanel.vue**
```vue
<template>
  <div class="cross-section-panel">
    <h3>横截面观测</h3>
    
    <el-radio-group v-model="sectionType" @change="updateSection">
      <el-radio-button label="coronal">冠状面</el-radio-button>
      <el-radio-button label="sagittal">矢状面</el-radio-button>
      <el-radio-button label="axial">横断面</el-radio-button>
    </el-radio-group>
    
    <div class="position-control">
      <label>截面位置：{{ (position * 100).toFixed(1) }}%</label>
      <el-slider
        v-model="position"
        :min="0"
        :max="1"
        :step="0.01"
        @change="updateSection"
      />
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import * as THREE from 'three'

const sectionType = ref('axial')
const position = ref(0.5)
let sectionPlane = null

function updateSection() {
  if (!window.modelRef) return
  
  // 创建截面平面
  const normal = new THREE.Vector3()
  let constant = 0
  
  switch (sectionType.value) {
    case 'coronal':
      normal.set(1, 0, 0)
      constant = (position.value - 0.5) * 2
      break
    case 'sagittal':
      normal.set(0, 1, 0)
      constant = (position.value - 0.5) * 2
      break
    case 'axial':
      normal.set(0, 0, 1)
      constant = (position.value - 0.5) * 2
      break
  }
  
  sectionPlane = new THREE.Plane(normal, constant)
  
  // 应用到所有模型
  window.modelRef.traverse((child) => {
    if (child.isMesh) {
      if (!Array.isArray(child.material)) {
        child.material.clippingPlanes = [sectionPlane]
        child.material.clipShadows = true
        child.material.needsUpdate = true
      } else {
        child.material.forEach(mat => {
          mat.clippingPlanes = [sectionPlane]
          mat.clipShadows = true
          mat.needsUpdate = true
        })
      }
    }
  })
}
</script>
```

### 4. 点击标注功能

**在 App.vue 中添加**
```javascript
import { Raycaster, Vector2 } from 'three'

// 点击事件处理
function onMouseClick(event) {
  const mouse = new Vector2()
  const rect = renderer.domElement.getBoundingClientRect()
  
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1
  
  const raycaster = new Raycaster()
  raycaster.setFromCamera(mouse, camera)
  
  const intersects = raycaster.intersectObjects(scene.children, true)
  
  if (intersects.length > 0) {
    const clickedObject = intersects[0].object
    const organId = clickedObject.userData.organId
    
    if (organId) {
      // 显示器官信息
      showOrganInfo(organId)
    }
  }
}

// 在 onMounted 中添加事件监听
renderer.domElement.addEventListener('click', onMouseClick)
```

### 5. 状态管理（Pinia）

**stores/sceneStore.js**
```javascript
import { defineStore } from 'pinia'
import { ref } from 'vue'

export const useSceneStore = defineStore('scene', () => {
  const selectedOrgan = ref(null)
  const visibleLayers = ref({
    skin: true,
    muscle: false,
    skeleton: false,
    organs: true,
    vessels: false
  })
  
  const crossSectionType = ref('axial')
  const crossSectionPosition = ref(0.5)
  
  function setSelectedOrgan(organ) {
    selectedOrgan.value = organ
  }
  
  function toggleLayer(layer, visible) {
    visibleLayers.value[layer] = visible
  }
  
  return {
    selectedOrgan,
    visibleLayers,
    crossSectionType,
    crossSectionPosition,
    setSelectedOrgan,
    toggleLayer
  }
})
```

## 四、生物知识数据

**data/anatomy.json**
```json
{
  "organs": [
    {
      "id": "heart",
      "name": "心脏",
      "nameEn": "Heart",
      "description": "心脏是循环系统的核心器官，负责将血液泵送到全身",
      "function": "泵血功能，维持血液循环",
      "location": "胸腔中部，偏左",
      "relatedDiseases": ["心脏病", "心律失常", "心肌梗死"],
      "relatedOrgans": ["lungs", "bloodVessels"]
    },
    {
      "id": "lungs",
      "name": "肺",
      "nameEn": "Lungs",
      "description": "肺是呼吸系统的主要器官，负责气体交换",
      "function": "气体交换，吸入氧气，呼出二氧化碳",
      "location": "胸腔两侧",
      "relatedDiseases": ["肺炎", "肺癌", "哮喘"],
      "relatedOrgans": ["heart", "trachea"]
    }
  ]
}
```

## 五、数据可视化

**ChartPanel.vue**
```vue
<template>
  <div class="chart-panel">
    <div ref="chartRef" style="width: 100%; height: 300px;"></div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import * as echarts from 'echarts'

const chartRef = ref(null)

onMounted(() => {
  const chart = echarts.init(chartRef.value)
  
  const option = {
    title: { text: '心率数据' },
    xAxis: { type: 'category', data: ['00:00', '06:00', '12:00', '18:00', '24:00'] },
    yAxis: { type: 'value' },
    series: [{
      data: [60, 65, 70, 75, 68],
      type: 'line'
    }]
  }
  
  chart.setOption(option)
})
</script>
```

## 六、总结

### 技术特点
- **简单直接**：使用 Three.js 原生 API，不依赖复杂封装
- **易于理解**：代码清晰，注释完善
- **快速开发**：使用成熟工具，快速实现功能

### 业务重点
- **解决实际问题**：每个功能都有明确的业务价值
- **用户体验**：界面简洁，操作流畅
- **易于扩展**：模块化设计，便于添加新功能

### 开发建议
1. **先实现核心功能**：3D 模型加载、基础交互
2. **再添加业务功能**：分层显示、横截面、标注
3. **最后优化体验**：UI 美化、性能优化

---

**核心理念**：用简单的技术解决复杂的业务问题，而不是用复杂的技术解决简单的问题。

