# 横截面观测功能详细设计

## 功能概述

横截面观测功能允许用户从多个角度（冠状面、矢状面、横断面）查看人体的内部结构，模拟医学影像（CT、MRI）的观察方式。这是生物科学研究中非常重要的功能。

## 核心特性

### 1. 多平面横截面
- **冠状面（Coronal Plane）**：前后方向切割，从正面观察
- **矢状面（Sagittal Plane）**：左右方向切割，从侧面观察
- **横断面（Axial Plane）**：上下方向切割，从顶部观察

### 2. 交互控制
- 实时调整截面位置（拖拽滑块）
- 切换截面方向（按钮切换）
- 多截面同时显示（三视图模式）
- 截面厚度调节（模拟切片厚度）

### 3. 可视化效果
- 截面边缘高亮
- 截面纹理渲染（显示内部结构）
- 截面轮廓线
- 截面标注（显示截面位置信息）

### 4. 高级功能
- 截面动画播放（自动扫描）
- 截面数据导出（保存截面图像）
- 截面测量（测量截面内结构尺寸）
- 截面对比（不同位置的截面对比）

## 技术实现方案

### 方案一：Clipping Planes（推荐）

使用 Three.js 的 ClippingPlanes 功能，这是最直接和高效的方法。

**优点**：
- 性能好，GPU 加速
- 实现简单
- 支持多个截面平面

**缺点**：
- 截面边缘需要额外处理
- 截面纹理需要自定义 Shader

### 方案二：CSG（构造实体几何）

使用 CSG 库进行布尔运算，生成截面几何体。

**优点**：
- 截面边缘精确
- 可以导出截面几何

**缺点**：
- 性能较差
- 计算复杂

### 方案三：Raycasting + Texture（混合方案）

结合射线检测和纹理渲染，生成截面图像。

**优点**：
- 可以生成高质量截面图像
- 支持复杂渲染效果

**缺点**：
- 实现复杂
- 需要额外的渲染通道

## 详细实现（方案一：Clipping Planes）

### 1. 基础截面实现

```typescript
// composables/useCrossSection.ts
import { ref, computed } from 'vue'
import { Plane, Vector3 } from 'three'
import { useThree } from '@tresjs/core'

export function useCrossSection() {
  const { scene } = useThree()
  
  // 截面类型
  type SectionType = 'coronal' | 'sagittal' | 'axial'
  
  // 当前截面类型
  const sectionType = ref<SectionType>('axial')
  
  // 截面位置（0-1，相对于模型范围）
  const sectionPosition = ref(0.5)
  
  // 截面厚度
  const sectionThickness = ref(0.02)
  
  // 创建截面平面
  const createSectionPlane = (type: SectionType, position: number): Plane => {
    const normal = new Vector3()
    const constant = 0
    
    switch (type) {
      case 'coronal': // 冠状面：Y-Z 平面，沿 X 轴移动
        normal.set(1, 0, 0)
        constant = (position - 0.5) * 2 // 归一化到 -1 到 1
        break
      case 'sagittal': // 矢状面：X-Z 平面，沿 Y 轴移动
        normal.set(0, 1, 0)
        constant = (position - 0.5) * 2
        break
      case 'axial': // 横断面：X-Y 平面，沿 Z 轴移动
        normal.set(0, 0, 1)
        constant = (position - 0.5) * 2
        break
    }
    
    return new Plane(normal, constant)
  }
  
  // 应用截面到场景
  const applySection = () => {
    const plane = createSectionPlane(sectionType.value, sectionPosition.value)
    
    scene.traverse((child) => {
      if (child.isMesh) {
        // 设置裁剪平面
        if (!Array.isArray(child.material)) {
          child.material.clippingPlanes = [plane]
          child.material.clipShadows = true
          child.material.needsUpdate = true
        } else {
          child.material.forEach(mat => {
            mat.clippingPlanes = [plane]
            mat.clipShadows = true
            mat.needsUpdate = true
          })
        }
      }
    })
  }
  
  // 更新截面位置
  const updateSectionPosition = (position: number) => {
    sectionPosition.value = position
    applySection()
  }
  
  // 切换截面类型
  const switchSectionType = (type: SectionType) => {
    sectionType.value = type
    applySection()
  }
  
  return {
    sectionType,
    sectionPosition,
    sectionThickness,
    updateSectionPosition,
    switchSectionType,
    applySection
  }
}
```

### 2. 截面边缘高亮

```typescript
// composables/useSectionEdge.ts
import { ref } from 'vue'
import { EdgesGeometry, LineSegments, LineBasicMaterial } from 'three'
import { useThree } from '@tresjs/core'

export function useSectionEdge() {
  const { scene } = useThree()
  const edgeLines = ref<LineSegments[]>([])
  
  // 创建截面边缘线
  const createEdgeLines = (mesh: THREE.Mesh) => {
    const edges = new EdgesGeometry(mesh.geometry)
    const material = new LineBasicMaterial({ 
      color: 0x00ff00,
      linewidth: 2 
    })
    const line = new LineSegments(edges, material)
    return line
  }
  
  // 更新截面边缘
  const updateEdges = () => {
    // 清除旧边缘
    edgeLines.value.forEach(line => scene.remove(line))
    edgeLines.value = []
    
    // 为每个被裁剪的 mesh 创建边缘
    scene.traverse((child) => {
      if (child.isMesh && child.material.clippingPlanes?.length > 0) {
        const edgeLine = createEdgeLines(child)
        edgeLine.position.copy(child.position)
        edgeLine.rotation.copy(child.rotation)
        edgeLine.scale.copy(child.scale)
        scene.add(edgeLine)
        edgeLines.value.push(edgeLine)
      }
    })
  }
  
  return {
    edgeLines,
    updateEdges
  }
}
```

### 3. 三视图模式

```typescript
// components/Scene/CrossSectionView.ts
import { defineComponent, ref, watch } from 'vue'
import { useCrossSection } from '@/composables/useCrossSection'
import { useThree } from '@tresjs/core'

export default defineComponent({
  name: 'CrossSectionView',
  setup() {
    const { sectionType, sectionPosition, switchSectionType, updateSectionPosition } = useCrossSection()
    const { camera, scene } = useThree()
    
    // 三视图模式
    const threeViewMode = ref(false)
    
    // 创建三视图相机
    const createThreeViewCameras = () => {
      const cameras = {
        coronal: new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 100),
        sagittal: new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 100),
        axial: new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 100)
      }
      
      // 设置相机位置
      cameras.coronal.position.set(5, 0, 0)
      cameras.coronal.lookAt(0, 0, 0)
      
      cameras.sagittal.position.set(0, 5, 0)
      cameras.sagittal.lookAt(0, 0, 0)
      
      cameras.axial.position.set(0, 0, 5)
      cameras.axial.lookAt(0, 0, 0)
      
      return cameras
    }
    
    return {
      sectionType,
      sectionPosition,
      threeViewMode,
      switchSectionType,
      updateSectionPosition
    }
  },
  template: `
    <div class="cross-section-controls">
      <div class="section-type-selector">
        <button @click="switchSectionType('coronal')">冠状面</button>
        <button @click="switchSectionType('sagittal')">矢状面</button>
        <button @click="switchSectionType('axial')">横断面</button>
      </div>
      
      <div class="section-position-control">
        <label>截面位置</label>
        <input 
          type="range" 
          min="0" 
          max="1" 
          step="0.01"
          v-model="sectionPosition"
          @input="updateSectionPosition(Number($event.target.value))"
        />
        <span>{{ (sectionPosition * 100).toFixed(1) }}%</span>
      </div>
      
      <div class="three-view-toggle">
        <label>
          <input type="checkbox" v-model="threeViewMode" />
          三视图模式
        </label>
      </div>
    </div>
  `
})
```

### 4. 截面纹理渲染（高级）

```typescript
// composables/useSectionTexture.ts
import { ref } from 'vue'
import { WebGLRenderTarget, ShaderMaterial } from 'three'
import { useThree } from '@tresjs/core'

export function useSectionTexture() {
  const { renderer, scene, camera } = useThree()
  const renderTarget = ref<WebGLRenderTarget | null>(null)
  
  // 截面 Shader
  const sectionShader = {
    uniforms: {
      time: { value: 0 },
      sectionPlane: { value: new THREE.Plane(new THREE.Vector3(0, 0, 1), 0) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform vec4 sectionPlane;
      varying vec3 vWorldPosition;
      
      void main() {
        float dist = dot(vWorldPosition, sectionPlane.xyz) + sectionPlane.w;
        
        // 截面边缘效果
        if (abs(dist) < 0.01) {
          gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0); // 黄色边缘
        } else if (dist < 0.0) {
          discard; // 裁剪掉截面后的部分
        } else {
          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
      }
    `
  }
  
  // 渲染截面纹理
  const renderSectionTexture = () => {
    if (!renderTarget.value) {
      renderTarget.value = new WebGLRenderTarget(512, 512)
    }
    
    renderer.render(scene, camera, renderTarget.value)
    return renderTarget.value.texture
  }
  
  return {
    sectionShader,
    renderSectionTexture
  }
}
```

### 5. 截面动画播放

```typescript
// composables/useSectionAnimation.ts
import { ref } from 'vue'
import { useCrossSection } from './useCrossSection'
import { gsap } from 'gsap'

export function useSectionAnimation() {
  const { sectionPosition, updateSectionPosition } = useCrossSection()
  const isAnimating = ref(false)
  
  // 播放截面扫描动画
  const playScanAnimation = (duration: number = 3) => {
    if (isAnimating.value) return
    
    isAnimating.value = true
    
    gsap.to(sectionPosition, {
      value: 1,
      duration,
      ease: 'linear',
      onUpdate: () => {
        updateSectionPosition(sectionPosition.value)
      },
      onComplete: () => {
        isAnimating.value = false
        // 重置位置
        gsap.to(sectionPosition, {
          value: 0,
          duration: 0.5
        })
      }
    })
  }
  
  // 停止动画
  const stopAnimation = () => {
    gsap.killTweensOf(sectionPosition)
    isAnimating.value = false
  }
  
  return {
    isAnimating,
    playScanAnimation,
    stopAnimation
  }
}
```

## UI 组件设计

### 截面控制面板

```vue
<!-- components/UI/CrossSectionPanel.vue -->
<template>
  <div class="cross-section-panel">
    <h3>横截面观测</h3>
    
    <!-- 截面类型选择 -->
    <div class="section-type-group">
      <el-radio-group v-model="sectionType" @change="switchSectionType">
        <el-radio-button label="coronal">冠状面</el-radio-button>
        <el-radio-button label="sagittal">矢状面</el-radio-button>
        <el-radio-button label="axial">横断面</el-radio-button>
      </el-radio-group>
    </div>
    
    <!-- 截面位置控制 -->
    <div class="section-position-group">
      <label>截面位置：{{ (sectionPosition * 100).toFixed(1) }}%</label>
      <el-slider
        v-model="sectionPosition"
        :min="0"
        :max="1"
        :step="0.01"
        @change="updateSectionPosition"
      />
    </div>
    
    <!-- 截面厚度控制 -->
    <div class="section-thickness-group">
      <label>截面厚度：{{ sectionThickness.toFixed(3) }}</label>
      <el-slider
        v-model="sectionThickness"
        :min="0.01"
        :max="0.1"
        :step="0.01"
      />
    </div>
    
    <!-- 功能按钮 -->
    <div class="section-actions">
      <el-button @click="playScanAnimation" :disabled="isAnimating">
        {{ isAnimating ? '扫描中...' : '播放扫描动画' }}
      </el-button>
      <el-button @click="toggleThreeView">
        {{ threeViewMode ? '退出' : '进入' }}三视图
      </el-button>
      <el-button @click="exportSectionImage">导出截面图</el-button>
    </div>
    
    <!-- 三视图显示 -->
    <div v-if="threeViewMode" class="three-view-container">
      <div class="view-item">
        <h4>冠状面</h4>
        <canvas ref="coronalCanvas"></canvas>
      </div>
      <div class="view-item">
        <h4>矢状面</h4>
        <canvas ref="sagittalCanvas"></canvas>
      </div>
      <div class="view-item">
        <h4>横断面</h4>
        <canvas ref="axialCanvas"></canvas>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useCrossSection } from '@/composables/useCrossSection'
import { useSectionAnimation } from '@/composables/useSectionAnimation'

const {
  sectionType,
  sectionPosition,
  sectionThickness,
  switchSectionType,
  updateSectionPosition
} = useCrossSection()

const { isAnimating, playScanAnimation } = useSectionAnimation()

const threeViewMode = ref(false)

const toggleThreeView = () => {
  threeViewMode.value = !threeViewMode.value
}

const exportSectionImage = () => {
  // 导出截面图像逻辑
}
</script>
```

## 性能优化

### 1. 截面计算优化
- 使用 Web Workers 进行截面计算
- 缓存截面结果
- 按需更新截面

### 2. 渲染优化
- 使用 InstancedMesh 渲染重复结构
- 视锥体剔除
- LOD 技术

### 3. 内存管理
- 及时释放不需要的截面数据
- 使用对象池管理截面对象

## 使用场景

1. **医学教育**：学生学习人体解剖结构
2. **医学研究**：研究人员分析内部结构
3. **临床诊断**：辅助医生理解 CT/MRI 影像
4. **手术规划**：术前查看患者内部结构

## 未来扩展

1. **真实 CT/MRI 数据集成**：导入真实的医学影像数据
2. **AI 辅助标注**：自动识别截面中的器官
3. **3D 重建**：从多个截面重建 3D 模型
4. **VR/AR 支持**：在 VR/AR 环境中查看截面

---

**关键提示**：横截面功能是生物科学研究的核心需求，实现这个功能能够很好地展示你对业务的理解和技术能力。

